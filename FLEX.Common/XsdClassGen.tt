<#@ template hostSpecific="true" debug="false" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data.Linq" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<# var manager = Manager.Create(Host, GenerationEnvironment); #>
//-----------------------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: <#=Environment.Version.ToString() #>
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------------------------------

<#
    var xsdClassGen = new XsdClassGen(manager.GetItemNamespace(Host.TemplateFile));
    var hostServiceProvider = (IServiceProvider) Host;
    var dte = (DTE) hostServiceProvider.GetService(typeof(DTE));
    var templateProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
    var project = templateProjectItem.ContainingProject;
    var paths = GetAllItems(project.ProjectItems.Cast<ProjectItem>()).Select(projectItem => projectItem.FileNames[0]).ToList();
    foreach (var path in paths.Where(path => path.EndsWith(".xsd"))) {
        xsdClassGen.AddSchema(path);
    }
    foreach (var path in paths.Where(path => path.EndsWith("XsdClassGen.mapping"))) {
        xsdClassGen.LoadMappings(path);
    }
    IDictionary<string, List<string>> typeNameMappings;
    using (var writer = new StringWriter(GenerationEnvironment)) {
        typeNameMappings = xsdClassGen.Generate(writer);
    }
    foreach (var codeNamespace in typeNameMappings.Keys) {
        foreach (var typeName in typeNameMappings[codeNamespace]) {
            manager.StartNewFile(codeNamespace + "." + typeName + ".cs");
#>
//-----------------------------------------------------------------------------------------------------
// <auto-generated>
//     This source code was auto-generated by XsdClassGen.tt.
//     Runtime Version: <#=Environment.Version.ToString() #>
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------------------------------

using System.IO;
using System.Xml;
using System.Xml.Serialization;

namespace <#= codeNamespace #>
{
	public partial class <#= typeName #>
	{
		public static <#= typeName #> DeserializeFrom(string str)
		{
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
		    using (var stream = new StringReader(str)) {
			    return serializer.Deserialize(stream) as <#= typeName #>;
		    }
		}

		public static <#= typeName #> DeserializeFrom(Stream stream)
		{
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			return serializer.Deserialize(stream) as <#= typeName #>;
		}

		public static <#= typeName #> DeserializeFrom(TextReader reader)
		{
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			return serializer.Deserialize(reader) as <#= typeName #>;
		}

		public static <#= typeName #> DeserializeFrom(XmlReader reader)
		{
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			return serializer.Deserialize(reader) as <#= typeName #>;
		}

		public void SerializeTo(ref string str)
		{
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
            using (var stream = new StringWriter()) {
			    serializer.Serialize(stream, this);
                str = stream.ToString();
            }
		}

		public void SerializeTo(Stream stream)
		{
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			serializer.Serialize(stream, this);
		}

		public void SerializeTo(TextWriter writer)
		{
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			serializer.Serialize(writer, this);
		}

		public void SerializeTo(XmlWriter writer)
		{
			var serializer = new XmlSerializer(typeof(<#= typeName #>));
			serializer.Serialize(writer, this);
		}
	}
}
<#
            manager.EndBlock();
        }
    }
    manager.Process(true);
#>
<#+

    private static IEnumerable<ProjectItem> GetAllItems(IEnumerable<ProjectItem> projectItems)
    {
        return projectItems.Concat(projectItems.SelectMany(i => GetAllItems(i.ProjectItems.Cast<ProjectItem>())));
    }

    public class XsdClassGen
    {
        private readonly CodeDomProvider _codeProvider;
        private readonly string _defaultCodeNamespace;
        private readonly Dictionary<string, SchemaMapping> _schemaMappings = new Dictionary<string, SchemaMapping>();
        private readonly XmlSchemas _schemas = new XmlSchemas();

        public XsdClassGen()
            : this(new CSharpCodeProvider(), "") {}

        public XsdClassGen(string defaultCodeNamespace)
            : this(new CSharpCodeProvider(), defaultCodeNamespace) {}

        public XsdClassGen(CodeDomProvider codeProvider, string defaultCodeNamespace)
        {
            _codeProvider = codeProvider;
            _defaultCodeNamespace = defaultCodeNamespace;
        }

        public void AddSchema(string path)
        {
            using (var stream = File.OpenRead(path)) {
                var schema = XmlSchema.Read(stream, null);
                _schemas.Add(schema);
                ApplySchemaNamespaceMapping(schema.TargetNamespace, _defaultCodeNamespace);
            }
        }

        public void LoadMappings(string path)
        {
            using (var reader = File.OpenText(path)) {
                string line;
                while ((line = reader.ReadLine()) != null) {
                    line = line.Trim();
                    if ((line.Length == 0) || (line.StartsWith("#"))) {
                        continue;
                    }
                    var mapping = line.Split(',');
                    if (mapping.Length == 2) {
                        ApplySchemaNamespaceMapping(mapping[0], mapping[1]);
                    }
                    if (mapping.Length == 3) {
                        ApplyTypeNameMapping(mapping[0], mapping[1], mapping[2]);
                    }
                }
            }
        }

        public void ApplySchemaNamespaceMapping(string schemaNamespace, string codeNamespace)
        {
            if (_schemaMappings.Keys.Contains(schemaNamespace)) {
                _schemaMappings[schemaNamespace].CodeNamespace = codeNamespace;
            } else {
                _schemaMappings.Add(schemaNamespace,
                    new SchemaMapping {SchemaNamespace = schemaNamespace, CodeNamespace = codeNamespace});
            }
        }

        public void ApplyTypeNameMapping(string schemaNamespace, string elementName, string typeName)
        {
            SchemaMapping mapping;
            if (_schemaMappings.Keys.Contains(schemaNamespace)) {
                mapping = _schemaMappings[schemaNamespace];
            } else {
                ApplySchemaNamespaceMapping(schemaNamespace, _defaultCodeNamespace);
                mapping = _schemaMappings[schemaNamespace];
            }
            if (mapping.TypeMappings.Keys.Contains(elementName)) {
                mapping.TypeMappings[elementName] = typeName;
            } else {
                mapping.TypeMappings.Add(elementName, typeName);
            }
        }

        public IDictionary<string, List<string>> Generate(TextWriter writer)
        {
            var rootElementTypes = new Dictionary<string, List<string>>();
            var codeGeneratorOptions = new CodeGeneratorOptions();
            var schemaImporter = new XmlSchemaImporter(_schemas);
            _schemas.Compile(null, true);
            foreach (var mapping in _schemaMappings.Values) {
                var codeNamespace = GenerateCodeForMapping(mapping, schemaImporter);
                _codeProvider.GenerateCodeFromNamespace(codeNamespace, writer, codeGeneratorOptions);
                var rootTypes = GetSchemaRootElementTypeNames(codeNamespace).ToList();
                if (rootElementTypes.ContainsKey(mapping.CodeNamespace)) {
                    var types = rootElementTypes[mapping.CodeNamespace];
                    types.AddRange(rootTypes);
                } else {
                    rootElementTypes.Add(mapping.CodeNamespace, rootTypes);
                }
            }
            return rootElementTypes;
        }

        private System.CodeDom.CodeNamespace GenerateCodeForMapping(SchemaMapping mapping, XmlSchemaImporter schemaImporter)
        {
            var codeNamespace = new System.CodeDom.CodeNamespace(mapping.CodeNamespace);
            var codeExporter = new XmlCodeExporter(codeNamespace);
            var maps = new List<XmlTypeMapping>();
            maps.AddRange(_schemas
                .Where(schema => schema.TargetNamespace == mapping.SchemaNamespace)
                .SelectMany(schema => schema.SchemaTypes.Values.Cast<XmlSchemaType>()
                    .Select(schemaType => schemaImporter.ImportSchemaType(schemaType.QualifiedName))));
            maps.AddRange(_schemas
                .Where(schema => schema.TargetNamespace == mapping.SchemaNamespace)
                .SelectMany(schema => schema.Elements.Values.Cast<XmlSchemaElement>()
                    .Select(schemaElement => schemaImporter.ImportTypeMapping(schemaElement.QualifiedName))));
            foreach (var map in maps) {
                codeExporter.ExportTypeMapping(map);
            }
            CodeGenerator.ValidateIdentifiers(codeNamespace);
            ApplyTypeMappings(codeNamespace, mapping);
            return codeNamespace;
        }

        private static void ApplyTypeMappings(System.CodeDom.CodeNamespace codeNamespace, SchemaMapping mapping)
        {
            foreach (var elementName in mapping.TypeMappings.Keys) {
                var typeName = mapping.TypeMappings[elementName];
                var codeType = FindTypeForSchemaRoot(codeNamespace, mapping.SchemaNamespace, elementName);
                var oldName = codeType.Name;
                codeType.Name = typeName;
                UpdateAttributeArguments<XmlRootAttribute>(codeType, "", oldName);
                UpdateAttributeArguments<XmlTypeAttribute>(codeType, "TypeName", oldName);
            }
        }

        private IEnumerable<string> GetSchemaRootElementTypeNames(System.CodeDom.CodeNamespace codeNamespace)
        {
            return _schemas
                .SelectMany(xsd => xsd.Elements.Values.Cast<XmlSchemaElement>())
                .Where(e => e.ElementSchemaType is XmlSchemaComplexType)
                .Select(e => FindTypeForSchemaRoot(codeNamespace, e.QualifiedName.Namespace, e.QualifiedName.Name))
                .Where(t => t != null)
                .Select(t => t.Name);
        }

        private static CodeTypeDeclaration FindTypeForSchemaRoot(System.CodeDom.CodeNamespace codeNamespace, string schemaNs, string elementName)
        {
            return codeNamespace.Types.Cast<CodeTypeDeclaration>().FirstOrDefault(t => HasXmlRootAttribute(t, schemaNs, elementName));
        }

        private static bool HasXmlRootAttribute(CodeTypeMember codeType, string schemaNs, string elementName)
        {
            var rootAttrib = GetCodeAttributeDeclaration<XmlRootAttribute>(codeType);
            if (rootAttrib == null) {
                return false;
            }
            var nsArg = GetAttributeArgument(rootAttrib, "Namespace");
            if (nsArg == null) {
                return false;
            }
            if ((string) GetAttributeArgumentValue(nsArg) != schemaNs) {
                return false;
            }
            var nameArg = GetAttributeArgument(rootAttrib, "");
            var name = codeType.Name;
            if (nameArg != null) {
                name = (string) GetAttributeArgumentValue(nameArg);
            }
            return name == elementName;
        }

        private static void UpdateAttributeArguments<T>(CodeTypeMember codeType, string findArg, string oldValue) where T : Attribute
        {
            var attrib = GetCodeAttributeDeclaration<T>(codeType);
            var arg = GetAttributeArgument(attrib, findArg);
            if (arg != null) {
                return;
            }
            arg = new CodeAttributeArgument(findArg, new CodePrimitiveExpression(oldValue));
            attrib.Arguments.Insert(0, arg);
        }

        private static CodeAttributeDeclaration GetCodeAttributeDeclaration<T>(CodeTypeMember type)
        {
            return type.CustomAttributes.Cast<CodeAttributeDeclaration>().FirstOrDefault(a => a.Name == typeof(T).FullName);
        }

        private static CodeAttributeArgument GetAttributeArgument(CodeAttributeDeclaration attribute, string argument)
        {
            return attribute.Arguments.Cast<CodeAttributeArgument>().FirstOrDefault(a => a.Name == argument);
        }

        private static object GetAttributeArgumentValue(CodeAttributeArgument arg)
        {
            return arg == null ? null : ((CodePrimitiveExpression) arg.Value).Value;
        }

        #region Nested type: SchemaMapping

        private class SchemaMapping
        {
            public SchemaMapping()
            {
                TypeMappings = new Dictionary<string, string>();
            }

            public string SchemaNamespace { get; set; }
            public string CodeNamespace { get; set; }
            public IDictionary<string, string> TypeMappings { get; private set; }
        }

        #endregion
    }

    // Manager class records the various blocks so it can split them up
    // From http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
    private class Manager
    {
        private readonly List<Block> files = new List<Block>();
        private readonly Block footer = new Block();
        protected readonly List<String> generatedFileNames = new List<String>();
        private readonly Block header = new Block();
        private readonly ITextTemplatingEngineHost host;
        private readonly StringBuilder template;
        private Block currentBlock;

        private Manager(ITextTemplatingEngineHost host, StringBuilder template)
        {
            this.host = host;
            this.template = template;
        }

        public virtual String DefaultProjectNamespace
        {
            get { return null; }
        }

        private Block CurrentBlock
        {
            get { return currentBlock; }
            set
            {
                if (CurrentBlock != null) {
                    EndBlock();
                }
                if (value != null) {
                    value.Start = template.Length;
                }
                currentBlock = value;
            }
        }

        public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template)
        {
            return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
        }

        public void StartNewFile(String name)
        {
            if (name == null) {
                throw new ArgumentNullException("name");
            }
            CurrentBlock = new Block {Name = name};
        }

        public void StartFooter()
        {
            CurrentBlock = footer;
        }

        public void StartHeader()
        {
            CurrentBlock = header;
        }

        public void EndBlock()
        {
            if (CurrentBlock == null) {
                return;
            }
            CurrentBlock.Length = template.Length - CurrentBlock.Start;
            if (CurrentBlock != header && CurrentBlock != footer) {
                files.Add(CurrentBlock);
            }
            currentBlock = null;
        }

        public virtual void Process(bool split)
        {
            if (split) {
                EndBlock();
                var headerText = template.ToString(header.Start, header.Length);
                var footerText = template.ToString(footer.Start, footer.Length);
                var outputPath = Path.GetDirectoryName(host.TemplateFile);
                files.Reverse();
                foreach (var block in files) {
                    var fileName = Path.Combine(outputPath, block.Name);
                    var content = headerText + template.ToString(block.Start, block.Length) + footerText;
                    generatedFileNames.Add(fileName);
                    CreateFile(fileName, content);
                    template.Remove(block.Start, block.Length);
                }
            }
        }

        protected virtual void CreateFile(String fileName, String content)
        {
            if (IsFileContentDifferent(fileName, content)) {
                File.WriteAllText(fileName, content);
            }
        }

        public virtual String GetCustomToolNamespace(String fileName)
        {
            return null;
        }

        public virtual String GetItemNamespace(String filename)
        {
            var customNamespace = GetCustomToolNamespace(filename);

            if (String.IsNullOrEmpty(customNamespace)) {
                return DefaultProjectNamespace;
            }

            return customNamespace;
        }

        protected static bool IsFileContentDifferent(String fileName, String newContent)
        {
            return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
        }

        #region Nested type: Block

        private class Block
        {
            public int Length;
            public String Name;
            public int Start;
        }

        #endregion

        #region Nested type: VSManager

        private class VSManager : Manager
        {
            private readonly Action<String> checkOutAction;
            private readonly DTE dte;
            private readonly Action<IEnumerable<String>> projectSyncAction;
            private readonly ProjectItem templateProjectItem;

            internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
                : base(host, template)
            {
                var hostServiceProvider = (IServiceProvider) host;
                if (hostServiceProvider == null) {
                    throw new ArgumentNullException("Could not obtain IServiceProvider");
                }
                dte = (DTE) hostServiceProvider.GetService(typeof(DTE));
                if (dte == null) {
                    throw new ArgumentNullException("Could not obtain DTE from host");
                }
                templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
                checkOutAction = fileName => dte.SourceControl.CheckOutItem(fileName);
                projectSyncAction = keepFileNames => ProjectSync(templateProjectItem, keepFileNames);
            }

            public override String DefaultProjectNamespace
            {
                get { return templateProjectItem.ContainingProject.Properties.Item("RootNamespace").Value.ToString(); }
            }

            public override String GetItemNamespace(String filename)
            {
                var customNamespace = GetCustomToolNamespace(filename);
                if (!String.IsNullOrEmpty(customNamespace)) {
                    return customNamespace;
                }

                var namespaces = new List<string>();
                var parent = templateProjectItem.Collection.Parent as ProjectItem;
                while (parent != null) {
                    if (parent.Kind != Constants.vsProjectItemKindPhysicalFile) {
                        namespaces.Insert(0, parent.Name.Replace(" ", string.Empty));
                    }

                    parent = parent.Collection.Parent as ProjectItem;
                }

                namespaces.Insert(0, DefaultProjectNamespace);
                return string.Join(".", namespaces.ToArray());
            }

            public override String GetCustomToolNamespace(string fileName)
            {
                return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
            }

            public override void Process(bool split)
            {
                if (templateProjectItem.ProjectItems == null) {
                    return;
                }
                base.Process(split);
                projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
            }

            protected override void CreateFile(String fileName, String content)
            {
                if (IsFileContentDifferent(fileName, content)) {
                    CheckoutFileIfRequired(fileName);
                    File.WriteAllText(fileName, content);
                }
            }

            private static void ProjectSync(ProjectItem templateProjectItem, IEnumerable<String> keepFileNames)
            {
                var keepFileNameSet = new HashSet<String>(keepFileNames);
                var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.FileNames[0]) + ".";
                var projectFiles = templateProjectItem.ProjectItems.Cast<ProjectItem>().ToDictionary(projectItem => projectItem.FileNames[0]);

                // Remove unused items from the project
                foreach (var pair in projectFiles) {
                    if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix)) {
                        pair.Value.Delete();
                    }
                }

                // Add missing files to the project
                foreach (var fileName in keepFileNameSet.Where(fileName => !projectFiles.ContainsKey(fileName))) {
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
                }
            }

            private void CheckoutFileIfRequired(String fileName)
            {
                var sc = dte.SourceControl;
                if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName)) {
                    checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
                }
            }
        }

        #endregion
    }

#>